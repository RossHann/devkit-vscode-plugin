<!DOCTYPE html>
<html lang="en" class="loading">

<head>
    <meta charset="utf-8" />
    <title>Kunpeng Hyper Tuner</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <style>
        @-webkit-keyframes ball-spin-fade-loader {
            50% {
                -webkit-transform: scale(0.4);
                transform: scale(0.4);
                opacity: 0.3;
            }

            100% {
                -webkit-transform: scale(1);
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes ball-spin-fade-loader {
            50% {
                -webkit-transform: scale(0.4);
                transform: scale(0.4);
                opacity: 0.3;
            }

            100% {
                -webkit-transform: scale(1);
                transform: scale(1);
                opacity: 1;
            }
        }

        .maskBox {
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .containerBox {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .circleBox {
            position: relative;
            width: 100px;
            height: 100px;
        }

        .circleItem {
            width: 25px;
            height: 25px;
            position: absolute;
            top: 37.5px;
            left: 37.5px;
        }

        .circleItem1 {
            transform: rotate(0) translate(37.5px);
        }

        .circleItem2 {
            transform: rotate(45deg) translate(37.5px);
        }

        .circleItem3 {
            transform: rotate(90deg) translate(37.5px);
        }

        .circleItem4 {
            transform: rotate(135deg) translate(37.5px);
        }

        .circleItem5 {
            transform: rotate(180deg) translate(37.5px);
        }

        .circleItem6 {
            transform: rotate(225deg) translate(37.5px);
        }

        .circleItem7 {
            transform: rotate(270deg) translate(37.5px);
        }

        .circleItem8 {
            transform: rotate(315deg) translate(37.5px);
        }

        .circle {
            width: 100%;
            height: 100%;
            animation-fill-mode: both;
            background-color: #0067ff;
            border-radius: 50%;
        }

        .circle1 {
            animation: ball-spin-fade-loader 1s 0.875s infinite linear
        }

        .circle2 {
            animation: ball-spin-fade-loader 1s 0.75s infinite linear
        }

        .circle3 {
            animation: ball-spin-fade-loader 1s 0.625s infinite linear
        }

        .circle4 {
            animation: ball-spin-fade-loader 1s 0.5s infinite linear
        }

        .circle5 {
            animation: ball-spin-fade-loader 1s 0.375s infinite linear
        }

        .circle6 {
            animation: ball-spin-fade-loader 1s 0.25s infinite linear
        }

        .circle7 {
            animation: ball-spin-fade-loader 1s 0.125s infinite linear
        }

        .circle8 {
            animation: ball-spin-fade-loader 1s 0s infinite linear
        }
    </style>
</head>
<script>
    // 此变量作为占位符，其内容值会被替换，用于页面第一次跳转
    self.navigatorPage;

    self.webviewSession = self.webviewSession || {
        setItem: function (key, value) {
            self.webviewSession[key] = value;
        },

        getItem: function (key) {
            return self.webviewSession[key];
        },

        removeItem: function (key) {
            delete self.webviewSession[key];
        }

    }

    // 初始化页面session
    const webSession = ((self.navigatorPage || {}).data || {}).webSession;
    if (webSession) {
        (self.webviewSession || {}).setItem('role', webSession.role);
        (self.webviewSession || {}).setItem('username', webSession.username);
        (self.webviewSession || {}).setItem('loginId', webSession.loginId);
        (self.webviewSession || {}).setItem('isFirst', webSession.isFirst);
        (self.webviewSession || {}).setItem('language', webSession.language);
        (self.webviewSession || {}).setItem('workspace', webSession.workspace);
    }
</script>

<body>
    <script id='profile-thread-worker' type="app/worker">
        const baseTop = 0;
        const gridHeight = 16;
        const gridInertvalHeight = 32;
        let defaultOptions = [];
        let defaultLen = 0;
        const deleteItems = {};
        const deleteStart = 3;
        let deleteStartLen = 15;
        let getDatas = {
            spec: [],
            values: {}
        };
        const sData = {};
        const fake = {};
        let startTime = 0;
        let endTime = 0;
        const optionsAll = {
            opts: {},
            default: {},
            xLabels: [],
            parsed: {}
        };
        let timeLineData = {start: 0,
            end: 100};

        addEventListener('message', function (data) {
            const newdata = data.data;
            if (newdata.type === 'default') {
                defaultOptions = newdata.data;
                defaultLen = defaultOptions.length;
            }

            if (newdata.type === 'ws') {
                const response = {type: 'normal', body: parseData(newdata.data)};
                postMessage(response);
            }

            if (newdata.type === 'download') {
                const response = {type: 'normal', body: parseDownloadData(newdata.data)};
                postMessage(response);
            }

            if (newdata.type === 'updateDataZoom') {
                upDateTimeLine(newdata.data.msg);
                const response = {type: 'timeUpdate', body: optionsAll.opts.dataZoom}
                postMessage(response);
            }
        });

        function parseDownloadData(data) {
            getDatas = { ...data };

            getDatas.spec.forEach(function (item, index) {
                sData[item.id] = [];
                fake[item.id] = [];

                getDatas.values[item.id].forEach(function (val, idx) {
                    let color = '#ffffff';
                    if (!val.status) {
                        return;
                    }
                    if (val.status === 'RUNNABLE') {
                        color = '#2DA46F'
                    } else if (val.status === 'WAITING' || val.status === 'TIMED_WAITING') {
                        color = '#DE9E09'
                    } else {
                        color = '#E85D54'
                    }
                    sData[item.id].push([
                        {
                            xAxis: val.start,
                            itemStyle: {
                                color
                            }
                        },
                        {
                            xAxis: Number(val.end) + 1000
                        }
                    ]);
                    fake[item.id].push({

                        name: item.name + ',' + idx,
                        value: [val.start, val.end]
                    });
                });
            });

            Object.keys(getDatas.values).forEach(function (key, index) {
                if (index === 0) {
                    const len = getDatas.values[key].length;
                    startTime = getDatas.values[key][0].start;
                    endTime = getDatas.values[key][len - 1].end;
                }
            });
            const options = updataOption(getDatas.spec);
            return options;
        }

        function parseData(data) {
            optionsAll.opts = {};
            optionsAll.default = {};

            data.thread.forEach(function (thread) {

                const datas = getDatas.spec.filter(function (item) {
                    return thread.threadId === item.id;
                });
                if (datas.length === 0) {
                    getDatas.spec.push({
                        name: thread.threadName,
                        id: thread.threadId
                    });
                }
            });
            if (!getDatas.spec.length) {
                return optionsAll;
            }
            endTime = data.endTime;
            const startTimeItem = data.startTime;
            optionsAll.xLabels.push(formatLabel(endTime / 1000));
            if (optionsAll.xLabels.length > 20) {
                optionsAll.xLabels.shift();
            }

            getDatas.spec.forEach(function (item, index) {
                sData[item.id] = [];
                fake[item.id] = [];

                const curThread = data.thread.filter(function (thr) {
                    return thr.threadId === item.id;
                });
                if (!getDatas.values[item.id]) {
                    getDatas.values[item.id] = [];
                    deleteItems[item.id] = 0;
                }
                getDatas.values[item.id].push({
                    start: startTimeItem,
                    end: endTime,
                    status: (curThread.length && curThread[0].threadState) || ''
                });
                if (curThread.length && curThread[0].threadState) {
                    deleteItems[item.id] += 1;
                } else {
                    deleteItems[item.id] -= 1;
                }

                if (deleteItems[item.id] < deleteStart && getDatas.values[item.id].length >= deleteStartLen) {
                    delete deleteItems[item.id];
                    delete getDatas.values[item.id];
                    delete sData[item.id];
                    delete fake[item.id];

                    defaultOptions = defaultOptions.filter(function (opt) {
                        return opt.id !== item.id;
                    });
                    getDatas.spec.splice(index, 1);
                } else {

                    getDatas.values[item.id].forEach(function (val, idx) {
                        let color = '#ffffff';
                        if (!val.status) {
                            return;
                        }
                        if (val.status === 'RUNNABLE') {
                            color = '#2DA46F'
                        } else if (val.status === 'WAITING' || val.status === 'TIMED_WAITING') {
                            color = '#DE9E09'
                        } else {
                            color = '#E85D54'
                        }
                        sData[item.id].push([
                            {
                                xAxis: val.start,
                                itemStyle: {
                                    color
                                }
                            },
                            {
                                xAxis: Number(val.end) + 1000
                            }
                        ]);
                        fake[item.id].push({

                            name: item.name + ',' + idx,
                            value: [val.start, val.end]
                        });
                    });
                }
            });

            Object.keys(getDatas.values).forEach(function (key, index) {
                deleteItems[key] = deleteItems[key] > 20 ? 20 : deleteItems[key];
                if (getDatas.values[key].length > 20) {
                    getDatas.values[key].shift();
                    if (sData[key].length > 20) {
                        sData[key].shift();
                    }
                    if (fake[key].length > 20) {
                        fake[key].shift();
                    }
                }

                if (index === 0) {
                    const len = getDatas.values[key].length;
                    startTime = getDatas.values[key][0].start;
                    endTime = getDatas.values[key][len - 1].end;
                }
            });
            if (getDatas.spec.length >= 150) {
                deleteStartLen = 10;
            } else {
                deleteStartLen = 15;
            }
            const options = updataOption(getDatas.spec);
            const optionsDefault = defaultOptions.length > 0 ? updataOption(defaultOptions) : undefined;
            optionsAll.opts = options;
            buildDataZoom(timeLineData);
            optionsAll.default = optionsDefault;
            optionsAll.parsed = getDatas;
            return optionsAll;

        }
        function updataOption(items) {
            const options = {
                series: [],
                grid: [],
                xAxis: [],
                yAxis: [],
                xAxisIndexArr: [],
                dataZoom: [{
                    start: 0,
                    end: 100,
                    xAxisIndex: [],
                    left: '1.3%',
                    right: '3.3%',
                    height: '18',
                    top: 0,
                    show: false,
                    textStyle: {
                        color: 'rgba(0,0,0,0)'
                    }
                }, {
                    type: 'inside',
                    zoomOnMouseWheel: false
                }],
            };

            items.forEach(function (item, index) {
                options.xAxisIndexArr.push(index * 2);
                options.xAxisIndexArr.push((index + 1) * 2 - 1);
                const offsetHeight = 0;
                options.grid.push(
                    makeGrid(
                        baseTop +
                        gridHeight * index +
                        (index + 1) * gridInertvalHeight,
                        {}
                    )
                );
                options.grid.push(
                    makeGrid(
                        baseTop +
                        gridHeight * index +
                        index * gridInertvalHeight +
                        offsetHeight,
                        {
                            show: false,
                            height: 0,
                            z: 1
                        }
                    )
                );
                options.series.push({
                    name: item.name + '(' + item.id + ')',
                    type: 'line',
                    symbol: 'circle',
                    symbolSize: 2,
                    coordinateSystem: 'cartesian2d',
                    xAxisIndex: index * 2,
                    yAxisIndex: index * 2,
                    markArea: {
                        data: sData[item.id]
                    }
                });
                options.series.push({
                    name: 'fake',
                    type: 'line',
                    symbol: 'none',
                    symbolSize: 2,
                    coordinateSystem: 'cartesian2d',
                    itemStyle: {
                        normal: { color: 'transparent' }
                    },
                    xAxisIndex: index * 2 + 1,
                    yAxisIndex: index * 2 + 1,
                    data: fake[item.id]
                });
                options.xAxis.push(
                    makeXAxis(index * 2, {
                        axisLine: { show: false },
                        min: startTime,
                        max: endTime,
                        axisPointer: {
                            show: false
                        }
                    })
                );
                options.xAxis.push(
                    makeXAxis(index * 2 + 1, {
                        position: 'top',
                        axisLine: { show: false, onZero: false },
                        axisPointer: {
                            show: false
                        }
                    })
                );
                options.yAxis.push(
                    makeYAxis(index * 2, {
                        name: item.name + item.id
                    })
                );
                options.yAxis.push(makeYAxis(index * 2 + 1, {}));
            });
            options.dataZoom[0].xAxisIndex = options.xAxisIndexArr;
            return options;
        }


        function makeXAxis(gridIndex, opt) {
            const options = {
                type: 'time',
                gridIndex,
                axisLine: { onZero: false, lineStyle: { color: '#ddd' } },
                axisTick: { show: false },
                axisLabel: {
                    show: false
                 },
                splitLine: { z: 1, show: true, interval: 0, lineStyle: {color: ['#484a4e'], width: 1 } },
                min: startTime,
                max: endTime
            };

            if (opt) {
                Object.assign(options, opt);
            }
            return options;
        }
        function formatLabel(time) {
            let date = new Date(); 
            let Y = date.getFullYear() + '-';
            let M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
            let D = (date.getDate() < 10 ? '0' + date.getDate() : date.getDate()) + ' ';
            let h = (date.getHours() < 10 ? '0'  + date.getHours() : date.getHours()) + ':';
            let m = (date.getMinutes() < 10 ? '0' + date.getMinutes() : date.getMinutes()) + ':';
            let s = (date.getSeconds() < 10 ? '0' + date.getSeconds() : date.getSeconds());            
            let strDate = h+m+s; 
            return strDate;
        }
        function makeYAxis(gridIndex, opt) {
            const options = {
                type: 'value',
                offset: 30,
                gridIndex,
                nameLocation: 'middle',
                nameTextStyle: {
                    color: '#333'
                },
                show: false,
                boundaryGap: ['30%', '30%'],
                axisTick: { show: false },
                axisLine: { lineStyle: { color: '#ccc' } },
                axisLabel: { show: false },
                splitLine: { show: false }
            };
            if (opt) {
                Object.assign(options, opt);
            }
            return options;
        }

        function makeGrid(top, opt) {
            const options = {
                top,
                left: 0,
                right: 60,
                height: gridHeight
            };
            if (opt) {
                Object.assign(options, opt);
            }
            return options;
        }

        function buildDataZoom(timeData) {
            optionsAll.opts.dataZoom[0].start = timeData.start;
            optionsAll.opts.dataZoom[0].end = timeData.end;
        }

        function upDateTimeLine(data) {
            optionsAll.opts.dataZoom[0].start = data.start;
            optionsAll.opts.dataZoom[0].end = data.end;
            timeLineData = data
        }
    </script>
    <script id="profile-file-io-worker" type="app/worker">
        let fileDatas = {};
        let earliestTime;
        const seocnd = 1000 * 1000;
        addEventListener('message', function (data) {
            const newdata = data.data;
            if (newdata.type === 'fileIOWs') {
                handleIoData(newdata.data);
                let data = getValues(fileDatas);
                if (earliestTime) {
                    data = limitData(data);
                }
                postMessage(data);
            }
            if (newdata.type === 'fileIOWs_close') {
                close();
            }
            if (newdata.type === 'dataLimit') {
                earliestTime = newdata.earliestTime;
            }
        });

        function limitData(data) {
            for (let i = 0; i < data.length; i++) {
                const file = data[i];
                const fdKeys = Object.keys(file.threads);
                fdKeys.forEach(fd => {
                    for (let j = 0; j < file.threads[fd].options.length; j++) {
                        const option = file.threads[fd].options[j];
                        if (option.originTime < earliestTime) {
                            file.threads[fd].options.splice(j, 1);
                            j--;
                        }
                    }
                    if (file.threads[fd].options.length === 0) {
                        delete file.threads[fd];
                    }
                })
                if (Object.keys(file.threads).length === 0) {
                    data.splice(i, 1);
                    i--;
                }
            }
            return data;
        }

        function handleIoData(data) {
            const newData = JSON.parse(JSON.stringify(fileDatas));
            data.forEach(function (item) {
                handle(newData, item);
            });
            fileDatas = newData;
        }

        function getValues(data) {
            let values = Object.values(data);
            values = values.sort(function (a, b) {
                return b.count - a.count;
            });
            return values;
        }

        function handle(fileDatas, item) {
            const filePath = item.attributes_.description;
            const threadName = item.attributes_.Thread;
            const fd = item.attributes_.fd;
            const byte = Number(item.attributes_.throughPut);
            const isWrite = item.methodName_.indexOf('write') >= 0;
            const isRead = item.methodName_.indexOf('read') >= 0;
            if (!fileDatas[filePath]) {
                fileDatas[filePath] = {
                    filePath,
                    duration: 0,
                    count: 0,
                    wCount: 0,
                    rCount: 0,
                    rByte: 0,
                    wByte: 0,
                    threads: {},
                    isSelect: false,
                    showDetails: false
                };
            }
            fileDatas[filePath].duration += item.duration_;
            fileDatas[filePath].count += isWrite || isRead ? 1 : 0;
            fileDatas[filePath].wCount += isWrite ? 1 : 0;
            fileDatas[filePath].rCount += isRead ? 1 : 0;
            fileDatas[filePath].rByte += isRead ? byte : 0;
            fileDatas[filePath].wByte += isWrite ? byte : 0;

            const root = { label: 'root', children: [] };
            const option = {
                stackTrace: trackFormat(item.allStackTraces_, root),
                start: dateFormat(item.start_, 'hh:mm:ss.S'),
                type: formatType(item.methodName_),
                duration: item.duration_,
                byte,
                threadName: '',
                rate: Number(onChangeRate(byte, item.duration_)),
                isSelect: false,
                originTime: item.start_
            };
            if (!fileDatas[filePath].threads[fd]) {
                fileDatas[filePath].threads[fd] = {
                    fd,
                    duration: 0,
                    count: 0,
                    writeCount: 0,
                    readCount: 0,
                    writeByte: 0,
                    readByte: 0,
                    options: [],
                    isSelect: false
                };
            }
            fileDatas[filePath].threads[fd].duration += item.duration_;
            fileDatas[filePath].threads[fd].count += isWrite || isRead ? 1 : 0;
            fileDatas[filePath].threads[fd].writeCount += isWrite ? 1 : 0;
            fileDatas[filePath].threads[fd].readCount += isRead ? 1 : 0;
            fileDatas[filePath].threads[fd].writeByte += isWrite ? byte : 0;
            fileDatas[filePath].threads[fd].readByte += isRead ? byte : 0;
            option.threadName = threadName;
            fileDatas[filePath].threads[fd].options.push(option);
        }

        function formatType(method) {
            if (method.indexOf('open') >= 0) {
                return 'open';
            }
            if (method.indexOf('close') >= 0) {
                return 'close';
            }
            if (method.indexOf('write') >= 0) {
                return 'write';
            }
            if (method.indexOf('read') >= 0) {
                return 'read';
            }
        }

        function trackFormat(stackTrack, theTree) {
            let node = theTree;
            stackTrack.forEach(item => {
                node.children = node.children || [];
                const label = item.className_ + ' ' + item.methodName_ + '(' + item.lineNum_ + ')';
                const obj = {
                    label,
                    expanded: true,
                    children: []
                };
                node.children.push(obj);
                node = obj;
            });
            return JSON.parse(JSON.stringify(theTree));
        }

        function dateFormat(date, fmt) {
            const getDate = new Date(date);
            const o = {
                'M+': getDate.getMonth() + 1,
                'd+': getDate.getDate(),
                'h+': getDate.getHours(),
                'm+': getDate.getMinutes(),
                's+': getDate.getSeconds(),
                'q+': Math.floor((getDate.getMonth() + 3) / 3),
                'S': getDate.getMilliseconds()
            };
            if (/(y+)/.test(fmt)) {
                fmt = fmt.replace(RegExp.$1, (String(getDate.getFullYear())).substr(4 - RegExp.$1.length));
            }
            for (const k in o) {
                if (new RegExp('(' + k + ')').test(fmt)) {
                    fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr((String(o[k])).length)));
                }
            }
            return fmt;
        }
        function onChangeRate(byte, dura) {
            if (byte === 0) {
                return 0;
            }
            if (dura === 0) {
                return 0;
            }
            const KB = (byte / 1024);
            const s = dura / seocnd;
            return (KB / s).toFixed(2);
        }
    </script>
    <script id="profile-socket-io-worker" type="app/worker">
        let fileDatas = {};
        let earliestTime;
        addEventListener('message', function (data) {
            const newdata = data.data;
            if (newdata.type === 'socketIOWs') {
                handleIoData(newdata.data);
                let data = getValues(fileDatas);
                if (earliestTime) {
                    data = limitData(data);
                }
                postMessage(data);
            }
            if (newdata.type === 'socketIOWs_close') {
                close();
            }
            if (newdata.type === 'dataLimit') {
                earliestTime = newdata.earliestTime;
            }
        });

        function limitData(data) {
            for (let i = 0; i < data.length; i++) {
                const host = data[i];
                const portKeys = Object.keys(host.host);
                portKeys.forEach(portKey => {
                    const port = host.host[portKey];
                    const fds = port.fds;
                    const fdKeys = Object.keys(fds);
                    fdKeys.forEach(fdKey => {
                        const fd = fds[fdKey];
                        const threads = fd.threads;
                        for (let j = 0; j < threads.length; j++) {
                            if (threads[j].originTime < earliestTime) {
                                threads.splice(j, 1);
                                j--;
                            }
                        }
                        if (threads.length === 0) {
                            delete fds[fdKey];
                        }
                    })
                    if (Object.keys(fds).length === 0) {
                        delete host.host[portKey]
                    }
                })
                if (Object.keys(host.host).length === 0) {
                    data.splice(i, 1);
                    i--;
                }
            }
            return data;
        }

        function handleIoData(data) {
            const newData = JSON.parse(JSON.stringify(fileDatas));
            data.forEach(function (item) {
                handle(newData, item);
            });
            fileDatas = newData;
        }

        function getValues(data) {
            let values = Object.values(data);
            values = values.sort(function (a, b) {
                return b.count - a.count;
            });
            return values;
        }

        function handle(fileDatas, item) {
            const descArr = item.attributes_.description.split(':');
            const ip = descArr[0];
            const host = descArr[1];
            const itemFd = item.attributes_.fd;
            const threadName = item.attributes_.threadName;
            const byte = Number(item.attributes_.throughPut);
            const type = item.attributes_.type;
            const isWrite = type === 'write';
            const isRead = type === 'read';
            if (!fileDatas[ip]) {
                fileDatas[ip] = {
                    ip,
                    duration: 0,
                    count: 0,
                    wCount: 0,
                    rCount: 0,
                    rByte: 0,
                    wByte: 0,
                    host: {},
                    children: [],
                    isSelect: false,
                    showDetails: false,
                    toggle:false
                };
            }
            fileDatas[ip].duration += item.duration_;
            fileDatas[ip].count += isWrite || isRead ? 1 : 0;
            fileDatas[ip].wCount += isWrite ? 1 : 0;
            fileDatas[ip].rCount += isRead ? 1 : 0;
            fileDatas[ip].rByte += isRead ? byte : 0;
            fileDatas[ip].wByte += isWrite ? byte : 0;
            const hostObj = fileDatas[ip].host;
            if (!hostObj[host]) {
                hostObj[host] = {
                    host,
                    duration: 0,
                    count: 0,
                    wCount: 0,
                    rCount: 0,
                    rByte: 0,
                    wByte: 0,
                    fds: {},
                    threads: {},
                    children: [],
                    isSelect: false,
                    showDetailsH: false,
                    toggle:false
                };
            }
            hostObj[host].duration += item.duration_;
            hostObj[host].count += isWrite || isRead ? 1 : 0;
            hostObj[host].wCount += isWrite ? 1 : 0;
            hostObj[host].rCount += isRead ? 1 : 0;
            hostObj[host].rByte += isRead ? byte : 0;
            hostObj[host].wByte += isWrite ? byte : 0;
            const fds = hostObj[host].fds;
            if (!fds[itemFd]) {
                fds[itemFd] = {
                    fd: itemFd,
                    duration: 0,
                    count: 0,
                    wCount: 0,
                    rCount: 0,
                    rByte: 0,
                    wByte: 0,
                    threads: [],
                    isSelect: false,
                };
            }
            fds[itemFd].duration += item.duration_;
            fds[itemFd].count += isWrite || isRead ? 1 : 0;
            fds[itemFd].wCount += isWrite ? 1 : 0;
            fds[itemFd].rCount += isRead ? 1 : 0;
            fds[itemFd].rByte += isRead ? byte : 0;
            fds[itemFd].wByte += isWrite ? byte : 0;
            const fdThreads = fds[itemFd].threads;
            const root = { label: 'root', children: [] };
            const option = {
                stackTrace: trackFormat(item.allStackTraces_, root),
                start: dateFormat(item.start_, 'hh:mm:ss.S'),
                type,
                threadName: '',
                duration: item.duration_,
                byte,
                originTime: item.start_
            };
            option.threadName = threadName;
            fdThreads.push(option);
        }

        function formatType(method) {
            if (method.indexOf('open') >= 0) {
                return 'open';
            }
            if (method.indexOf('close') >= 0) {
                return 'close';
            }
            if (method.indexOf('write') >= 0) {
                return 'write';
            }
            if (method.indexOf('read') >= 0) {
                return 'read';
            }
        }

        function trackFormat(stackTrack, theTree) {
            let node = theTree;
            stackTrack.forEach(item => {
                node.children = node.children || [];
                const label = item.className_ + ' ' + item.methodName_ + '(' + item.lineNum_ + ')';
                const obj = {
                    label,
                    expanded: true,
                    children: []
                };
                node.children.push(obj);
                node = obj;
            });
            return JSON.parse(JSON.stringify(theTree));
        }

        function dateFormat(date, fmt) {
            const getDate = new Date(date);
            const o = {
                'M+': getDate.getMonth() + 1,
                'd+': getDate.getDate(),
                'h+': getDate.getHours(),
                'm+': getDate.getMinutes(),
                's+': getDate.getSeconds(),
                'q+': Math.floor((getDate.getMonth() + 3) / 3),
                'S': getDate.getMilliseconds()
            };
            if (/(y+)/.test(fmt)) {
                fmt = fmt.replace(RegExp.$1, (String(getDate.getFullYear())).substr(4 - RegExp.$1.length));
            }
            for (const k in o) {
                if (new RegExp('(' + k + ')').test(fmt)) {
                    fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) :
                        (('00' + o[k]).substr((String(o[k])).length)));
                }
            }
            return fmt;
        }
    </script>
    <script id="sample-file-io-worker" type="app/worker">
        addEventListener('message', function (data) {
            const newdata = data.data;
            if (newdata.type === 'sFileioWorker') {
                const data2 = handleData(newdata.data)
                postMessage(data2);
            }
            if (newdata.type === 'sFileioWorker_close') {
                close();
            }
        });
        function handleData(data) {
            const tableListData = []
            let fileIOData = {}
            data.content.forEach(item => {
                const fileData = {};
                handleSampleFileIOData(fileData, item);
                const data = handleViewData(fileData)[0]
                tableListData.push(data);
                fileIOData = Object.assign(fileIOData, fileData);
            });
            return { tableListData, fileIOData };
        }
        function handleSampleFileIOData(fileData, data) {
            const path = data.path;
            const baseIO = data.basicIOSummary;
            const timeZone = data.timeZone.sort();
            const threadsMap = data.ioSummaryMap;
            handleBasicIOData(fileData, path, baseIO, timeZone);
            for (const key in threadsMap) {
                if (Object.prototype.hasOwnProperty.call(threadsMap, key)) {
                    const element = threadsMap[key];
                    handleBasicIOData(fileData[path].threads, key, element, timeZone);
                }
            }
        }
        function handleBasicIOData(target, path, baseIO, timeZone) {
            if (!target[path]) {
                target[path] = {
                    path,
                    totalIOTime: 0,
                    totalCount: 0,
                    readCount: 0,
                    writeCount: 0,
                    bytesRead: 0,
                    bytesWritten: 0,
                    readSpeed: [],
                    writeSpeed: [],
                    timeList: [],
                    stackTrace: [],
                    threads: {},
                    isSelect: false
                };
            }
            target[path].totalIOTime += baseIO.totalIOTime;
            target[path].totalCount += baseIO.totalCount;
            target[path].readCount += baseIO.readCount;
            target[path].writeCount += baseIO.writeCount;
            target[path].bytesRead += baseIO.bytesRead;
            target[path].bytesWritten += baseIO.bytesWritten;
            target[path].timeList = timeZone;
            target[path].readSpeed = handleSpeedList(timeZone,baseIO.readEventMap);
            target[path].writeSpeed = handleSpeedList(timeZone,baseIO.writeEventMap);
        }
        function handleSpeedList(timeZone, speedListData) {
            let speedList = Object.values 
              ? Object.values(speedListData) 
              : Object.keys(speedListData).map(function (key) {
                  return speedListData[key];
                });
            let speed = new Array(timeZone.length).fill(0);
            if (speedList.length !== 0) {
              speedList.forEach(function (item) {
                const index = timeZone.findIndex(function (time) {
                  return time === Math.ceil(item.startTime / 1000)
                })
                if (index !== -1) {
                  speed[index] = item.speed;
                }
              });
            }
            return speed;
          }
        function handleViewData(threadsData) {
            if (threadsData) {
                return Object.values(threadsData);
            }
            return Object.values(this.fileIOData);
        }
    </script>
    <script id="sample-socket-io-worker" type="app/worker">
        addEventListener('message', function (data) {
            const newdata = data.data;
            if (newdata.type === 'sSocketioWorker') {
                const tableListData = handleData(newdata.data);
                postMessage({tableListData});
            }
            if (newdata.type === 'sSocketioWorker_close') {
                close();
            }
        });
        function handleData(data) {
            const tableListData = []
            data.content.forEach(item => {
                const fileData = {};
                handleSampleFileIOData(fileData, item);
                const data = handleViewData(fileData)[0];
                tableListData.push(data);
            });
            return tableListData;
        }
        function handleSampleFileIOData(fileData, data) {
            const path = data.ip;
            const baseIO = data.basicIOSummary;
            const timeZone = data.timeZone.sort();
            const threadsMap = data.ioSummaryMap;
            handleBasicIOData(fileData, path, baseIO, timeZone);
            for (const key in threadsMap) {
                if (Object.prototype.hasOwnProperty.call(threadsMap, key)) {
                    const element = threadsMap[key].basicIOSummary;
                    const threads = threadsMap[key].threadIOSummaryMap;
                    handleBasicIOData(fileData[path].threads, key, element, timeZone);
                    for (const keys in threads) {
                        if (Object.prototype.hasOwnProperty.call(threads, keys)) {
                            const ele = threads[keys];
                            handleBasicIOData(fileData[path].threads[key].threads, keys, ele, timeZone);
                        }
                    }
                }
            }
        }
        function handleBasicIOData (target, path, baseIO, timeZone) {
            if (!target[path]) {
                target[path] = {
                    path,
                    totalIOTime: 0,
                    totalCount: 0,
                    readCount: 0,
                    writeCount: 0,
                    bytesRead: 0,
                    bytesWritten: 0,
                    readSpeed: [],
                    writeSpeed: [],
                    timeList: [],
                    stackTrace: [],
                    threads: {}
                };
            }
            target[path].totalIOTime += baseIO.totalIOTime;
            target[path].totalCount += baseIO.totalCount;
            target[path].readCount += baseIO.readCount;
            target[path].writeCount += baseIO.writeCount;
            target[path].bytesRead += baseIO.bytesRead;
            target[path].bytesWritten += baseIO.bytesWritten;
            target[path].timeList = timeZone;
            target[path].readSpeed = handleSpeedList(timeZone,baseIO.readEventMap);
            target[path].writeSpeed = handleSpeedList(timeZone,baseIO.writeEventMap);
        }
        function handleSpeedList(timeZone, speedListData) {
            let speedList = Object.values 
              ? Object.values(speedListData) 
              : Object.keys(speedListData).map(function (key) {
                  return speedListData[key];
                });
            let speed = new Array(timeZone.length).fill(0);
            if (speedList.length !== 0) {
              speedList.forEach(function (item) {
                const index = timeZone.findIndex(function (time) {
                  return time === Math.ceil(item.startTime / 1000)
                })
                if (index !== -1) {
                  speed[index] = item.speed;
                }
              });
            }
            return speed;
          }
        function handleViewData(threadsData) {
            if (threadsData) {
                return Object.values(threadsData);
            }
            return Object.values(fileIOData);
        }
    </script>
    <app-root>
        <div class="maskBox">
            <div class="containerBox">
                <div class="circleBox">
                    <div class="circleItem circleItem1">
                        <div class="circle circle1"></div>
                    </div>
                    <div class="circleItem circleItem2">
                        <div class="circle circle2"></div>
                    </div>
                    <div class="circleItem circleItem3">
                        <div class="circle circle3"></div>
                    </div>
                    <div class="circleItem circleItem4">
                        <div class="circle circle4"></div>
                    </div>
                    <div class="circleItem circleItem5">
                        <div class="circle circle5"></div>
                    </div>
                    <div class="circleItem circleItem6">
                        <div class="circle circle6"></div>
                    </div>
                    <div class="circleItem circleItem7">
                        <div class="circle circle7"></div>
                    </div>
                    <div class="circleItem circleItem8">
                        <div class="circle circle8"></div>
                    </div>
                </div>
            </div>
        </div>
    </app-root>
</body>

</html>